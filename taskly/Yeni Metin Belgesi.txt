import streamlit as st
import pandas as pd
from datetime import datetime, timedelta
import re
import json
import os
import io

# Streamlit Sayfa YapÄ±landÄ±rmasÄ±
st.set_page_config(
    page_title="GÃ¶rev Takip Sistemi",
    page_icon="ğŸ“‹",
    layout="wide"
)

# Veri dosyasÄ± yolu
DATA_FILE = "gorevler_v2.json" # Changed filename to avoid conflict with old data

# Veri yÃ¼kleme ve kaydetme fonksiyonlarÄ±
def load_tasks():
    """GÃ¶revleri dosyadan yÃ¼kle"""
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
                for task in data:
                    if task.get('termin') and isinstance(task['termin'], str):
                        task['termin'] = datetime.fromisoformat(task['termin'])
                    if task.get('olusturma') and isinstance(task['olusturma'], str):
                        task['olusturma'] = datetime.fromisoformat(task['olusturma'])
                    if task.get('tamamlanma') and isinstance(task['tamamlanma'], str):
                        task['tamamlanma'] = datetime.fromisoformat(task['tamamlanma'])
                return data
        except Exception as e:
            st.error(f"Veri yÃ¼kleme hatasÄ±: {e}")
    return []

def save_tasks(tasks):
    """GÃ¶revleri dosyaya kaydet"""
    try:
        data_to_save = []
        for task in tasks:
            task_copy = task.copy()
            if task_copy.get('termin') and isinstance(task_copy['termin'], datetime):
                task_copy['termin'] = task_copy['termin'].isoformat()
            if task_copy.get('olusturma') and isinstance(task_copy['olusturma'], datetime):
                task_copy['olusturma'] = task_copy['olusturma'].isoformat()
            if task_copy.get('tamamlanma') and isinstance(task_copy['tamamlanma'], datetime):
                task_copy['tamamlanma'] = task_copy['tamamlanma'].isoformat()
            data_to_save.append(task_copy)
        
        with open(DATA_FILE, 'w', encoding='utf-8') as f:
            json.dump(data_to_save, f, ensure_ascii=False, indent=2)
        return True
    except Exception as e:
        st.error(f"Veri kaydetme hatasÄ±: {e}")
        return False

# Session state'de gÃ¶revleri sakla
if 'task_db' not in st.session_state:
    st.session_state.task_db = load_tasks()

if 'selected_tasks_to_delete' not in st.session_state:
    st.session_state.selected_tasks_to_delete = set()

if 'selected_tasks_in_trash' not in st.session_state:
    st.session_state.selected_tasks_in_trash = set()


# YardÄ±mcÄ± fonksiyonlar
def get_next_task_id():
    """Benzersiz yeni gÃ¶rev ID'si oluÅŸtur"""
    if not st.session_state.task_db:
        return 1
    return max(task['id'] for task in st.session_state.task_db) + 1

def parse_date(text):
    """Tarih metinlerini datetime objesine Ã§evir"""
    if not text:
        return None
    formats = ["%d.%m.%Y", "%d/%m/%Y", "%Y-%m-%d", "%d-%m-%Y", "%d.%m.%y", "%d/%m/%y"]
    for fmt in formats:
        try:
            return datetime.strptime(text.strip(), fmt)
        except ValueError:
            continue
    return None

def extract_task_info(text):
    """DoÄŸal dil metninden gÃ¶rev bilgilerini Ã§Ä±kar"""
    if not text.strip():
        return None
    
    parsed = {
        "gorev": "-", "kategori": "-", "termin": None,
        "periyot": "-", "sorumlu": "-", "not": text.strip() # Default note is the full text
    }
    
    lines = text.strip().split('\n')
    first_line_processed_for_note = False

    if lines:
        first_line = lines[0].strip()
        # VirgÃ¼lle ayrÄ±lmÄ±ÅŸ metni iÅŸle (GÃ¶rev, Tarih, Kategori, Sorumlu, Not)
        if ',' in first_line:
            parts = [p.strip() for p in first_line.split(',')]
            parsed["gorev"] = parts[0]
            
            if len(parts) > 1:
                date_candidate = parse_date(parts[1])
                if date_candidate:
                    parsed["termin"] = date_candidate
                    if len(parts) > 2: parsed["kategori"] = parts[2]
                    if len(parts) > 3: parsed["sorumlu"] = parts[3]
                    if len(parts) > 4: 
                        parsed["not"] = ", ".join(parts[4:]) # Note from 5th part onwards
                        first_line_processed_for_note = True
                else: # parts[1] is not a date, so it's kategori
                    parsed["kategori"] = parts[1]
                    if len(parts) > 2: parsed["sorumlu"] = parts[2]
                    if len(parts) > 3: 
                        parsed["not"] = ", ".join(parts[3:]) # Note from 4th part onwards
                        first_line_processed_for_note = True
        else: # VirgÃ¼l yoksa ilk satÄ±rÄ± gÃ¶rev adÄ± olarak al
             if not re.search(r"\d{1,2}[./\-]\d{1,2}[./\-]\d{2,4}", first_line): # Check if it's not just a date
                parsed["gorev"] = first_line


    # Belirli anahtar kelimeleri tara (Not: anahtar kelimesi virgÃ¼llÃ¼ notu ezer)
    # DiÄŸer anahtar kelimeler de ilgili alanlarÄ± doldurur
    temp_note_lines = []
    for line_idx, line_content in enumerate(lines):
        line = line_content.strip()
        # Skip first line if it was fully processed by comma logic for note
        if line_idx == 0 and first_line_processed_for_note:
            continue

        if line.lower().startswith('gorev:'):
            # Only override if not set by first line logic or if explicitly different
            candidate_gorev = line[len('gorev:'):].strip()
            if parsed["gorev"] == "-" or (line_idx > 0 and parsed["gorev"] != candidate_gorev) :
                 parsed["gorev"] = candidate_gorev or "-"
        elif line.lower().startswith('termin:') or (not parsed.get("termin") and parse_date(line) and not parsed.get("gorev") == line): # Check if line itself is a date
            date_str = line[len('termin:'):].strip() if line.lower().startswith('termin:') else line
            dt = parse_date(date_str)
            if dt: parsed["termin"] = dt
            elif line_idx > 0 or not first_line_processed_for_note : temp_note_lines.append(line_content) # Add to note if not parsed
        elif line.lower().startswith('kategori:'):
            parsed["kategori"] = line[len('kategori:'):].strip() or "-"
        elif line.lower().startswith('sorumlu:'):
            parsed["sorumlu"] = line[len('sorumlu:'):].strip() or "-"
        elif line.lower().startswith('periyot:'):
            periyot_match = re.search(r"periyot[:\-\s]+(\d+)(?:\s*(gÃ¼n|ay))?", line, re.IGNORECASE)
            if periyot_match:
                days = int(periyot_match.group(1))
                if periyot_match.group(2) and 'ay' in periyot_match.group(2).lower():
                    days *= 30
                parsed["periyot"] = str(days) + " gÃ¼n"
            elif line_idx > 0 or not first_line_processed_for_note : temp_note_lines.append(line_content)
        elif line.lower().startswith('not:'):
            parsed["not"] = line[len('not:'):].strip() # Explicit "Not:" keyword overrides previous note content
            temp_note_lines = [line[len('not:'):].strip()] # Start afresh for note lines
            first_line_processed_for_note = True # Consider note explicitly handled
        elif line_idx > 0 or (line_idx == 0 and not first_line_processed_for_note and parsed["gorev"] != line_content.strip()):
            # Add to temp_note_lines if not a keyword and not the main task name line (if it was the only content)
            temp_note_lines.append(line_content)
    
    # If note wasn't set by CSV or "Not:" keyword, and temp_note_lines exist, use them.
    if not first_line_processed_for_note and temp_note_lines:
        final_note = "\n".join(temp_note_lines).strip()
        # Avoid setting note to be identical to task name if task name is the only input
        if len(lines) == 1 and parsed["gorev"] == final_note and parsed["gorev"] != "-":
            if not any(parsed[k] and parsed[k] != "-" for k in ["kategori", "termin", "periyot", "sorumlu"]):
                 parsed["not"] = "-"
            else:
                 parsed["not"] = final_note
        else:
            parsed["not"] = final_note
    elif not parsed["not"] and (parsed["gorev"] == text.strip()): # Single line input, only task name
        parsed["not"] = "-"


    # Eksik bilgileri - ile doldur
    for key in ["gorev", "kategori", "sorumlu", "periyot", "not"]:
        if not parsed.get(key): # Check if key exists, then if it's empty
            parsed[key] = "-"
            
    if parsed["termin"] is None and parsed.get("termin", "-") != "-": # Ensure it's explicitly None, not already "-"
        parsed["termin"] = "-"
        
    return parsed


def add_task(parsed_data):
    """Yeni gÃ¶rev ekle"""
    if not parsed_data or parsed_data["gorev"] == "-":
        return False, "GÃ¶rev adÄ± gerekli!"
    
    new_task = {
        "id": get_next_task_id(),
        "gorev": parsed_data["gorev"],
        "kategori": parsed_data["kategori"],
        "termin": parsed_data["termin"] if parsed_data["termin"] != "-" else None,
        "periyot": parsed_data["periyot"] if parsed_data["periyot"] != "-" else None,
        "sorumlu": parsed_data["sorumlu"],
        "not": parsed_data["not"] if parsed_data["not"] != "-" else "", # Store empty string for no note
        "durum": "bekliyor", # 'bekliyor', 'tamamlandi', 'silindi'
        "olusturma": datetime.now(),
        "tamamlanma": None
    }
    
    st.session_state.task_db.append(new_task)
    save_tasks(st.session_state.task_db)
    return True, "GÃ¶rev baÅŸarÄ±yla eklendi!"

def complete_task(task_id):
    """GÃ¶revi tamamla"""
    task_found = False
    task_name_completed = ""
    for task in st.session_state.task_db:
        if task['id'] == task_id and task['durum'] == 'bekliyor':
            task['durum'] = 'tamamlandi'
            task['tamamlanma'] = datetime.now()
            task_name_completed = task['gorev']
            task_found = True
            
            # Periyodik gÃ¶rev ise yenisini oluÅŸtur
            if task.get('periyot') and task.get('termin'):
                try:
                    periyot_days = int(task['periyot'].split()[0])
                    new_date = task['termin'] + timedelta(days=periyot_days)
                    
                    new_periodic_task = task.copy()
                    new_periodic_task['id'] = get_next_task_id()
                    new_periodic_task['termin'] = new_date
                    new_periodic_task['durum'] = 'bekliyor'
                    new_periodic_task['olusturma'] = datetime.now()
                    new_periodic_task['tamamlanma'] = None # Reset tamamlanma
                    
                    st.session_state.task_db.append(new_periodic_task)
                except ValueError:
                    st.warning(f"Periyot formatÄ± ({task['periyot']}) anlaÅŸÄ±lamadÄ±, yinelenen gÃ¶rev oluÅŸturulamadÄ±.")
            break 
    
    if task_found:
        save_tasks(st.session_state.task_db)
        return f"âœ… GÃ¶rev tamamlandÄ±: {task_name_completed}"
    return "âŒ Tamamlanacak gÃ¶rev bulunamadÄ± veya zaten tamamlanmÄ±ÅŸ."


def update_task_note_by_id(task_id, new_note):
    """GÃ¶rev notunu ID ile gÃ¼ncelle (deÄŸiÅŸtir)"""
    task_found = False
    for task in st.session_state.task_db:
        if task['id'] == task_id:
            task['not'] = new_note
            task_found = True
            break
    
    if task_found:
        save_tasks(st.session_state.task_db)
        return f"âœ… Not gÃ¼ncellendi: {task['gorev']}"
    return "âŒ GÃ¶rev bulunamadÄ±."

def move_task_to_trash(task_id):
    """GÃ¶revi Ã§Ã¶p kutusuna taÅŸÄ±"""
    task_found = False
    for task in st.session_state.task_db:
        if task['id'] == task_id:
            task['durum'] = 'silindi' # Mark as deleted
            task_found = True
            break
    if task_found:
        save_tasks(st.session_state.task_db)
        return True
    return False

def restore_task_from_trash(task_id):
    """GÃ¶revi Ã§Ã¶p kutusundan geri yÃ¼kle"""
    task_found = False
    for task in st.session_state.task_db:
        if task['id'] == task_id and task['durum'] == 'silindi':
            task['durum'] = 'bekliyor' # Restore to pending
            task['tamamlanma'] = None # Clear completion date if any
            task_found = True
            break
    if task_found:
        save_tasks(st.session_state.task_db)
        return True
    return False

def permanently_delete_task(task_id):
    """GÃ¶revi kalÄ±cÄ± olarak sil"""
    original_len = len(st.session_state.task_db)
    st.session_state.task_db = [task for task in st.session_state.task_db if task['id'] != task_id]
    if len(st.session_state.task_db) < original_len:
        save_tasks(st.session_state.task_db)
        return True
    return False

# Filtreleme fonksiyonlarÄ± (silinmiÅŸ gÃ¶revleri dÄ±ÅŸarÄ±da bÄ±rakacak ÅŸekilde gÃ¼ncellendi)
def get_active_tasks():
    """Aktif (silinmemiÅŸ) gÃ¶revleri getir"""
    return [task for task in st.session_state.task_db if task['durum'] != 'silindi']

def get_tasks_for_period(days=7, reference_date=None):
    """Belirli bir dÃ¶nem iÃ§in bekleyen gÃ¶revleri getir"""
    if reference_date is None:
        reference_date = datetime.now()
    
    end_date = reference_date + timedelta(days=days)
    
    return [
        task for task in get_active_tasks() 
        if task.get('termin') and 
           task['termin'] <= end_date and 
           task['durum'] == 'bekliyor'
    ]

def search_tasks(query):
    """Aktif gÃ¶revlerde arama yap"""
    if not query:
        return []
    query = query.lower()
    return [
        task for task in get_active_tasks()
        if query in task['gorev'].lower() or 
           query in (task.get('not') or '').lower() or
           query in (task.get('kategori') or '').lower()
    ]

def get_tasks_by_status(status):
    """Duruma gÃ¶re aktif gÃ¶revleri getir ('bekliyor' veya 'tamamlandi')"""
    return [task for task in get_active_tasks() if task['durum'] == status]

def get_deleted_tasks():
    """SilinmiÅŸ gÃ¶revleri (Ã§Ã¶p kutusu) getir"""
    return [task for task in st.session_state.task_db if task['durum'] == 'silindi']


def get_tasks_by_category(category):
    """Kategoriye gÃ¶re aktif gÃ¶revleri getir"""
    return [
        task for task in get_active_tasks() 
        if task.get('kategori') and category.lower() in task['kategori'].lower()
    ]

def tasks_to_dataframe(tasks):
    """GÃ¶revleri pandas DataFrame'e Ã§evir"""
    data = []
    for task in tasks:
        data.append({
            "ID": task['id'],
            "GÃ¶rev": task['gorev'],
            "Kategori": task.get('kategori', '-'),
            "Termin": task['termin'].strftime('%d.%m.%Y') if task.get('termin') else '-',
            "Sorumlu": task.get('sorumlu', '-'),
            "Periyot": task.get('periyot') or '-',
            "Durum": task['durum'].capitalize(),
            "OluÅŸturma": task['olusturma'].strftime('%d.%m.%Y %H:%M') if task.get('olusturma') else '-',
            "Tamamlanma": task['tamamlanma'].strftime('%d.%m.%Y %H:%M') if task.get('tamamlanma') else '-',
            "Not": task.get('not', '')
        })
    return pd.DataFrame(data)

def download_excel(df, filename):
    """DataFrame'i Excel dosyasÄ± olarak indirme baÄŸlantÄ±sÄ± oluÅŸtur"""
    buffer = io.BytesIO()
    df.to_excel(buffer, index=False, engine='openpyxl')
    buffer.seek(0)
    return buffer

# Streamlit ArayÃ¼zÃ¼
st.markdown("<h2 style='text-align: center; color: #4CAF50;'>ğŸ“‹ AkÄ±llÄ± GÃ¶rev Takip Sistemi</h2>", unsafe_allow_html=True)
st.markdown("---")

# Sidebar menÃ¼
with st.sidebar:
    st.header("ğŸ¯ MenÃ¼")
    menu_options = [
        "ğŸ“ Yeni GÃ¶rev", "ğŸ“… Bu Hafta", "ğŸ“‹ TÃ¼m GÃ¶revler", 
        "âœ… Tamamlananlar", "ğŸ“ Kategoriler", "ğŸ” Arama",
        "âœ”ï¸ GÃ¶rev Tamamla", "ğŸ“ Not GÃ¼ncelle", "ğŸ“Š Ä°statistikler", "ğŸ—‘ï¸ Ã‡Ã¶p Kutusu"
    ]
    menu = st.radio("Ä°ÅŸlem SeÃ§in:", menu_options)
    
    st.markdown("---")
    st.subheader("ğŸ“Š Ã–zet (Aktif GÃ¶revler)")
    bekleyen = len(get_tasks_by_status('bekliyor'))
    tamamlanan_aktif = len(get_tasks_by_status('tamamlandi'))
    st.metric("Bekleyen GÃ¶revler", bekleyen)
    st.metric("Tamamlanan GÃ¶revler (Aktif)", tamamlanan_aktif)
    st.metric("Ã‡Ã¶p Kutusundaki GÃ¶revler", len(get_deleted_tasks()))


# Ana iÃ§erik
if menu == "ğŸ“ Yeni GÃ¶rev":
    st.header("ğŸ“ Yeni GÃ¶rev Ekle")
    
    with st.form("new_task_form"):
        st.markdown("""
        **GÃ¶rev bilgilerini aÅŸaÄŸÄ±daki formatlarda yazabilirsiniz:**
        - Tek satÄ±r: `GÃ¶rev AdÄ±, Tarih (Ã¶rn: 5.06.2025), Kategori, Sorumlu, Notunuz`
        - Ã‡ok satÄ±r (anahtar kelimelerle): `GÃ¶rev: Proje sunumu hazÄ±rla Termin: 15.12.2024 Kategori: Ä°ÅŸ Sorumlu: Ahmet Periyot: 30 gÃ¼n Not: Sunum detaylarÄ± ve Ã¶nemli noktalar...`
        Eksik bilgiler '-' veya boÅŸ olarak kaydedilir. 'Not' alanÄ± iÃ§in virgÃ¼llÃ¼ formatta en sona yazÄ±lanlar veya 'Not:' anahtar kelimesi kullanÄ±lÄ±r.
        """)
        
        task_text = st.text_area(
            "GÃ¶rev AÃ§Ä±klamasÄ± ve DetaylarÄ±:",
            height=200,
            placeholder="EKX BakÄ±m, 5.06.2025, bakÄ±m, GokselA, YÄ±llÄ±k kontrol yapÄ±lacak.\n\nveya\n\nGÃ¶rev: Raporu tamamla\nTermin: 20.08.2025\nNot: Ä°statistikleri eklemeyi unutma."
        )
        
        submitted = st.form_submit_button("ğŸ’¾ GÃ¶revi Kaydet", type="primary")
        
        if submitted:
            if task_text.strip():
                parsed = extract_task_info(task_text)
                if parsed:
                    success, message = add_task(parsed)
                    if success:
                        st.success(message)
                        st.balloons()
                    else:
                        st.error(message)
                else:
                    st.error("GÃ¶rev bilgileri ayrÄ±ÅŸtÄ±rÄ±lamadÄ±.")
            else:
                st.warning("LÃ¼tfen gÃ¶rev bilgilerini girin!")

elif menu == "ğŸ“… Bu Hafta":
    st.header("ğŸ“… Bu Hafta YapÄ±lacaklar (Bekleyen)")
    
    col1, col2 = st.columns([3, 1])
    with col2:
        days = st.selectbox("DÃ¶nem:", [7, 14, 30], index=0, format_func=lambda x: f"{x} gÃ¼n")
    
    tasks = get_tasks_for_period(days)
    if tasks:
        tasks.sort(key=lambda x: (x.get('termin') or datetime.max, x.get('olusturma') or datetime.min))
        df = tasks_to_dataframe(tasks)
        st.dataframe(df[["ID", "GÃ¶rev", "Kategori", "Termin", "Sorumlu"]], use_container_width=True) # Removed .set_column_width and let Streamlit handle it
        
        excel_buffer = download_excel(df, "bu_hafta_gorevler.xlsx")
        st.download_button(
            label="ğŸ“¥ Excel'e Ä°ndir", data=excel_buffer,
            file_name="bu_hafta_gorevler.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
    else:
        st.info(f"ğŸ“… Ã–nÃ¼mÃ¼zdeki {days} gÃ¼n iÃ§inde ve geÃ§miÅŸte bekleyen gÃ¶rev bulunmuyor.")

elif menu == "ğŸ“‹ TÃ¼m GÃ¶revler":
    st.header("ğŸ“‹ TÃ¼m Aktif GÃ¶revler")
    
    col1, col2, col3 = st.columns(3)
    with col1:
        durum_filter = st.selectbox("Durum:", ["TÃ¼mÃ¼ (Aktif)", "Bekliyor", "TamamlandÄ±"], key="tum_durum_filter")
    with col2:
        sort_by = st.selectbox("SÄ±ralama:", ["Termin", "OluÅŸturma", "GÃ¶rev AdÄ±"], key="tum_sort_by")
    with col3:
        order = st.selectbox("SÄ±ra:", ["Artan", "Azalan"], key="tum_order")
    
    tasks_to_show = []
    if durum_filter == "Bekliyor":
        tasks_to_show = get_tasks_by_status('bekliyor')
    elif durum_filter == "TamamlandÄ±":
        tasks_to_show = get_tasks_by_status('tamamlandi')
    else: # TÃ¼mÃ¼ (Aktif)
        tasks_to_show = get_active_tasks() # Shows both 'bekliyor' and 'tamamlandi'
    
    if sort_by == "Termin":
        tasks_to_show.sort(key=lambda x: (x.get('termin') or (datetime.max if order == "Artan" else datetime.min)), reverse=(order == "Azalan"))
    elif sort_by == "OluÅŸturma":
        tasks_to_show.sort(key=lambda x: x['olusturma'], reverse=(order == "Azalan"))
    else: # GÃ¶rev AdÄ±
        tasks_to_show.sort(key=lambda x: x['gorev'].lower(), reverse=(order == "Azalan"))
    
    st.markdown("---")
    
    selected_task_ids_for_trash = []
    if tasks_to_show:
        st.write(f"ğŸ“Š Toplam **{len(tasks_to_show)}** aktif gÃ¶rev bulundu.")
        
        df = tasks_to_dataframe(tasks_to_show)
        st.dataframe(df, use_container_width=True)
        
        # Checkboxes for deletion (moved outside of main dataframe for better control)
        st.subheader("GÃ¶revleri Ã‡Ã¶p Kutusuna TaÅŸÄ±")
        with st.expander("GÃ¶rev SeÃ§ ve Sil", expanded=False):
            for task in tasks_to_show:
                cols = st.columns([0.5, 3])
                with cols[0]:
                    if st.checkbox("", key=f"select_task_to_delete_{task['id']}", help="Silmek iÃ§in seÃ§"):
                        selected_task_ids_for_trash.append(task['id'])
                with cols[1]:
                    st.write(f"ID: {task['id']} - **{task['gorev']}**")

            if selected_task_ids_for_trash:
                if st.button("ğŸ—‘ï¸ SeÃ§ilenleri Ã‡Ã¶p Kutusuna TaÅŸÄ±", type="primary"):
                    deleted_count = 0
                    for task_id in selected_task_ids_for_trash:
                        if move_task_to_trash(task_id):
                            deleted_count +=1
                    st.success(f"{deleted_count} gÃ¶rev Ã§Ã¶p kutusuna taÅŸÄ±ndÄ±.")
                    st.session_state.selected_tasks_to_delete.clear() # Clear selection
                    st.rerun()
        
        st.markdown("---")
        # Download button for the filtered/sorted list
        excel_buffer_all = download_excel(df, "tum_aktif_gorevler.xlsx")
        st.download_button(
            label="ğŸ“¥ TÃ¼m Listeyi Excel'e Ä°ndir", data=excel_buffer_all,
            file_name="tum_aktif_gorevler.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
    else:
        st.info("Filtrelerinize uygun aktif gÃ¶rev bulunamadÄ±.")


elif menu == "âœ… Tamamlananlar":
    st.header("âœ… Tamamlanan Aktif GÃ¶revler")
    
    completed_tasks = get_tasks_by_status('tamamlandi')
    completed_tasks.sort(key=lambda x: x.get('tamamlanma', datetime.min), reverse=True)
    
    if completed_tasks:
        st.success(f"ğŸ‰ Toplam **{len(completed_tasks)}** aktif gÃ¶rev tamamlandÄ±!")
        df = tasks_to_dataframe(completed_tasks)
        st.dataframe(df, use_container_width=True)
        
        excel_buffer = download_excel(df, "tamamlanan_gorevler.xlsx")
        st.download_button(
            label="ğŸ“¥ Excel'e Ä°ndir", data=excel_buffer,
            file_name="tamamlanan_gorevler.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
    else:
        st.info("HenÃ¼z tamamlanmÄ±ÅŸ aktif gÃ¶rev bulunmuyor.")

elif menu == "ğŸ“ Kategoriler":
    st.header("ğŸ“ Kategoriye GÃ¶re Aktif GÃ¶revler")
    
    active_tasks = get_active_tasks()
    categories = set()
    for task in active_tasks:
        if task.get('kategori') and task['kategori'] != '-':
            categories.add(task['kategori'])
    
    if categories:
        selected_category = st.selectbox("Kategori SeÃ§in:", sorted(list(categories)))
        
        if selected_category:
            category_tasks = get_tasks_by_category(selected_category)
            category_tasks.sort(key=lambda x: (x.get('termin') or datetime.max, x.get('olusturma') or datetime.min))

            if category_tasks:
                st.write(f"ğŸ“Š **{selected_category}** kategorisinde **{len(category_tasks)}** aktif gÃ¶rev bulundu.")
                df = tasks_to_dataframe(category_tasks)
                st.dataframe(df, use_container_width=True)
                
                excel_buffer = download_excel(df, f"{selected_category}_gorevler.xlsx")
                st.download_button(
                    label="ğŸ“¥ Excel'e Ä°ndir", data=excel_buffer,
                    file_name=f"{selected_category}_gorevler.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                )
            else:
                st.info("Bu kategoride aktif gÃ¶rev bulunamadÄ±.")
    else:
        st.info("HenÃ¼z kategorize edilmiÅŸ aktif gÃ¶rev bulunmuyor.")

elif menu == "ğŸ” Arama":
    st.header("ğŸ” Aktif GÃ¶revlerde Arama")
    
    search_query = st.text_input("ğŸ” Arama terimi girin:", placeholder="GÃ¶rev adÄ±, kategori veya not iÃ§eriÄŸi...")
    
    if search_query:
        results = search_tasks(search_query)
        results.sort(key=lambda x: (x.get('termin') or datetime.max, x.get('olusturma') or datetime.min))
        
        if results:
            st.success(f"ğŸ¯ **{len(results)}** sonuÃ§ bulundu.")
            df = tasks_to_dataframe(results)
            st.dataframe(df, use_container_width=True)
            
            excel_buffer = download_excel(df, "arama_sonuclari.xlsx")
            st.download_button(
                label="ğŸ“¥ Excel'e Ä°ndir", data=excel_buffer,
                file_name="arama_sonuclari.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )
        else:
            st.warning("Arama kriterinize uygun aktif gÃ¶rev bulunamadÄ±.")

elif menu == "âœ”ï¸ GÃ¶rev Tamamla":
    st.header("âœ”ï¸ GÃ¶rev Tamamla")
    
    pending_tasks = get_tasks_by_status('bekliyor')
    pending_tasks.sort(key=lambda x: (x.get('termin') or datetime.max, x.get('olusturma') or datetime.min))

    if pending_tasks:
        task_options = {f"{task['gorev']} (ID: {task['id']})": task['id'] for task in pending_tasks}
        selected_task_display_name = st.selectbox("Tamamlanacak gÃ¶revi seÃ§in:", list(task_options.keys()))
        
        if selected_task_display_name:
            selected_task_id = task_options[selected_task_display_name]
            if st.button("âœ… TamamlandÄ± Olarak Ä°ÅŸaretle", type="primary"):
                result = complete_task(selected_task_id)
                st.success(result) # complete_task now returns a success message
                st.rerun()
    else:
        st.info("Tamamlanacak bekleyen gÃ¶rev bulunmuyor.")

elif menu == "ğŸ“ Not GÃ¼ncelle":
    st.header("ğŸ“ Not GÃ¼ncelleme")
    
    all_active_tasks = get_active_tasks()
    all_active_tasks.sort(key=lambda x: (x.get('termin') or datetime.max, x.get('olusturma') or datetime.min))

    if all_active_tasks:
        task_options = {f"{task['gorev']} (ID: {task['id']})": task['id'] for task in all_active_tasks}
        selected_task_display_name = st.selectbox("Notu gÃ¼ncellenecek gÃ¶revi seÃ§in:", list(task_options.keys()))
        
        if selected_task_display_name:
            selected_task_id = task_options[selected_task_display_name]
            task_to_edit = next((t for t in all_active_tasks if t['id'] == selected_task_id), None)

            if task_to_edit:
                current_note = task_to_edit.get('not', '')
                new_note_content = st.text_area("Notu DÃ¼zenle:", value=current_note, height=150)
                
                if st.button("ğŸ’¾ Notu GÃ¼ncelle", type="primary"):
                    result = update_task_note_by_id(selected_task_id, new_note_content)
                    st.success(result)
                    st.rerun()
            else:
                st.error("SeÃ§ilen gÃ¶rev bulunamadÄ±.")
    else:
        st.info("Notu gÃ¼ncellenecek aktif gÃ¶rev bulunmuyor.")

elif menu == "ğŸ—‘ï¸ Ã‡Ã¶p Kutusu":
    st.header("ğŸ—‘ï¸ Ã‡Ã¶p Kutusu")
    deleted_tasks = get_deleted_tasks()
    deleted_tasks.sort(key=lambda x: x.get('olusturma') or datetime.min, reverse=True) # Show newest deleted first

    if not deleted_tasks:
        st.info("Ã‡Ã¶p kutusu boÅŸ.")
    else:
        st.write(f"Ã‡Ã¶p kutusunda **{len(deleted_tasks)}** gÃ¶rev bulunuyor.")
        
        selected_trash_ids_perm_delete = []
        selected_trash_ids_restore = []

        for task in deleted_tasks:
            cols = st.columns([0.5, 0.5, 3, 2, 2]) # Perm Del Check, Restore Check, GÃ¶rev, Silinme Tarihi (yaklaÅŸÄ±k), Not
            with cols[0]:
                if st.checkbox("ğŸ—‘ï¸", key=f"trash_perm_del_{task['id']}", help="KalÄ±cÄ± silmek iÃ§in seÃ§"):
                    selected_trash_ids_perm_delete.append(task['id'])
            with cols[1]:
                if st.checkbox("ğŸ”„", key=f"trash_restore_{task['id']}", help="Geri yÃ¼klemek iÃ§in seÃ§"):
                    selected_trash_ids_restore.append(task['id'])
            with cols[2]:
                st.markdown(f"**{task['gorev']}**")
                st.caption(f"ID: {task['id']}")
            with cols[3]:
                # Silinme tarihi saklanmÄ±yor, oluÅŸturma tarihi gÃ¶sterilebilir veya genel bir bilgi
                st.caption(f"OluÅŸturma: {task['olusturma'].strftime('%d.%m.%Y') if task.get('olusturma') else '-'}")
            with cols[4]:
                 if task.get('not'):
                    with st.expander("Notu GÃ¶r", expanded=False):
                        st.caption(task['not'])
            st.markdown("---")


        col_actions1, col_actions2, col_actions3 = st.columns(3)
        with col_actions1:
            if selected_trash_ids_perm_delete:
                if st.button("ğŸ”¥ SeÃ§ilenleri KalÄ±cÄ± Sil", type="primary"):
                    count = 0
                    for task_id in selected_trash_ids_perm_delete:
                        if permanently_delete_task(task_id):
                            count +=1
                    st.success(f"{count} gÃ¶rev kalÄ±cÄ± olarak silindi.")
                    st.session_state.selected_tasks_in_trash.clear()
                    st.rerun()
        with col_actions2:
            if selected_trash_ids_restore:
                 if st.button("ğŸ”„ SeÃ§ilenleri Geri YÃ¼kle"):
                    count = 0
                    for task_id in selected_trash_ids_restore:
                        if restore_task_from_trash(task_id):
                            count +=1
                    st.success(f"{count} gÃ¶rev geri yÃ¼klendi.")
                    st.session_state.selected_tasks_in_trash.clear() # Clear selection
                    st.rerun()
        
        with col_actions3:
            if st.button("ğŸ’¥ TÃ¼m Ã‡Ã¶p Kutusunu BoÅŸalt", type="secondary"):
                confirm_empty = st.checkbox("TÃ¼mÃ¼nÃ¼ kalÄ±cÄ± olarak silmeyi onayla", key="confirm_empty_trash")
                if confirm_empty: # This button needs to be pressed again after checkbox for safety
                    if st.button("OnaylÄ±yorum, Hepsini Sil!"):
                        count = 0
                        for task in list(deleted_tasks): # Iterate over a copy
                            if permanently_delete_task(task['id']):
                                count +=1
                        st.success(f"Ã‡Ã¶p kutusundaki {count} gÃ¶revin tÃ¼mÃ¼ kalÄ±cÄ± olarak silindi.")
                        st.rerun()


elif menu == "ğŸ“Š Ä°statistikler":
    st.header("ğŸ“Š GÃ¶rev Ä°statistikleri")
    
    total_tasks_in_db = len(st.session_state.task_db)
    active_pending_tasks = len(get_tasks_by_status('bekliyor'))
    active_completed_tasks = len(get_tasks_by_status('tamamlandi'))
    deleted_task_count = len(get_deleted_tasks())
    total_active_tasks = active_pending_tasks + active_completed_tasks
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("Toplam KayÄ±tlÄ± GÃ¶rev (DB)", total_tasks_in_db)
    with col2:
        st.metric("Aktif Bekleyen", active_pending_tasks)
    with col3:
        st.metric("Aktif Tamamlanan", active_completed_tasks)
    with col4:
        completion_rate = (active_completed_tasks / total_active_tasks * 100) if total_active_tasks > 0 else 0
        st.metric("Aktif Tamamlanma OranÄ±", f"{completion_rate:.1f}%")
    
    st.metric("Ã‡Ã¶p Kutusundaki GÃ¶revler", deleted_task_count, delta_color="off")


    st.subheader("ğŸ“ Aktif GÃ¶revlerin Kategori DaÄŸÄ±lÄ±mÄ±")
    categories = {}
    for task in get_active_tasks(): # Only active tasks for this stat
        cat = task.get('kategori') or 'Kategorisiz'
        if cat == "-": cat = 'Kategorisiz'
        categories[cat] = categories.get(cat, 0) + 1
    
    if categories:
        cat_df = pd.DataFrame(list(categories.items()), columns=['Kategori', 'GÃ¶rev SayÄ±sÄ±'])
        cat_df = cat_df.sort_values(by='GÃ¶rev SayÄ±sÄ±', ascending=False)
        st.dataframe(cat_df, use_container_width=True)
        
        # Basic bar chart
        try:
            import altair as alt
            chart = alt.Chart(cat_df).mark_bar().encode(
                x=alt.X('Kategori', sort=None),
                y='GÃ¶rev SayÄ±sÄ±',
                tooltip=['Kategori', 'GÃ¶rev SayÄ±sÄ±']
            ).properties(
                title='Kategoriye GÃ¶re Aktif GÃ¶rev SayÄ±larÄ±'
            )
            st.altair_chart(chart, use_container_width=True)
        except ImportError:
            st.info("Grafik gÃ¶sterimi iÃ§in 'altair' kÃ¼tÃ¼phanesi kurulabilir: pip install altair")

    else:
        st.info("Aktif gÃ¶revlerde kategori bilgisi bulunmuyor.")


# Footer
st.markdown("---")
st.markdown("ğŸ’¡ **Ä°pucu:** GÃ¶rev bilgilerini hÄ±zlÄ±ca girmek iÃ§in virgÃ¼lle ayÄ±rabilirsiniz: `GÃ¶rev AdÄ±, Tarih, Kategori, Sorumlu, Notunuz`. Daha detaylÄ± giriÅŸ iÃ§in anahtar kelimeleri kullanÄ±n (Ã¶rn: `Termin: GG.AA.YYYY`).")